// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: header.proto

#ifndef PROTOBUF_header_2eproto__INCLUDED
#define PROTOBUF_header_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_header_2eproto();
void protobuf_AssignDesc_header_2eproto();
void protobuf_ShutdownFile_header_2eproto();

class Modification;
class ModTable;
class Header;
class Header_Source;
class Header_RawProteinsHeader;
class Header_PeptidesHeader;
class Header_SpectraHeader;
class Header_ResultsHeader;
class Header_AuxLocationsHeader;

enum Header_FileType {
  Header_FileType_RAW_PROTEINS = 0,
  Header_FileType_PEPTIDES = 1,
  Header_FileType_SPECTRA = 2,
  Header_FileType_PARAMS = 3,
  Header_FileType_MOD_TABLE = 4,
  Header_FileType_RESULTS = 5,
  Header_FileType_AUX_LOCATIONS = 6
};
bool Header_FileType_IsValid(int value);
const Header_FileType Header_FileType_FileType_MIN = Header_FileType_RAW_PROTEINS;
const Header_FileType Header_FileType_FileType_MAX = Header_FileType_AUX_LOCATIONS;
const int Header_FileType_FileType_ARRAYSIZE = Header_FileType_FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_FileType_descriptor();
inline const ::std::string& Header_FileType_Name(Header_FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_FileType_descriptor(), value);
}
inline bool Header_FileType_Parse(
    const ::std::string& name, Header_FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_FileType>(
    Header_FileType_descriptor(), name, value);
}
// ===================================================================

class Modification : public ::google::protobuf::Message {
 public:
  Modification();
  virtual ~Modification();

  Modification(const Modification& from);

  inline Modification& operator=(const Modification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Modification& default_instance();

  void Swap(Modification* other);

  // implements Message ----------------------------------------------

  Modification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Modification& from);
  void MergeFrom(const Modification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string amino_acids = 1;
  inline bool has_amino_acids() const;
  inline void clear_amino_acids();
  static const int kAminoAcidsFieldNumber = 1;
  inline const ::std::string& amino_acids() const;
  inline void set_amino_acids(const ::std::string& value);
  inline void set_amino_acids(const char* value);
  inline void set_amino_acids(const char* value, size_t size);
  inline ::std::string* mutable_amino_acids();
  inline ::std::string* release_amino_acids();
  inline void set_allocated_amino_acids(::std::string* amino_acids);

  // optional double delta = 2;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 2;
  inline double delta() const;
  inline void set_delta(double value);

  // optional int32 max_count = 3;
  inline bool has_max_count() const;
  inline void clear_max_count();
  static const int kMaxCountFieldNumber = 3;
  inline ::google::protobuf::int32 max_count() const;
  inline void set_max_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Modification)
 private:
  inline void set_has_amino_acids();
  inline void clear_has_amino_acids();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_max_count();
  inline void clear_has_max_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* amino_acids_;
  double delta_;
  ::google::protobuf::int32 max_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Modification* default_instance_;
};
// -------------------------------------------------------------------

class ModTable : public ::google::protobuf::Message {
 public:
  ModTable();
  virtual ~ModTable();

  ModTable(const ModTable& from);

  inline ModTable& operator=(const ModTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModTable& default_instance();

  void Swap(ModTable* other);

  // implements Message ----------------------------------------------

  ModTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModTable& from);
  void MergeFrom(const ModTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Modification variable_mod = 1;
  inline int variable_mod_size() const;
  inline void clear_variable_mod();
  static const int kVariableModFieldNumber = 1;
  inline const ::pb::Modification& variable_mod(int index) const;
  inline ::pb::Modification* mutable_variable_mod(int index);
  inline ::pb::Modification* add_variable_mod();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Modification >&
      variable_mod() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Modification >*
      mutable_variable_mod();

  // repeated .pb.Modification static_mod = 2;
  inline int static_mod_size() const;
  inline void clear_static_mod();
  static const int kStaticModFieldNumber = 2;
  inline const ::pb::Modification& static_mod(int index) const;
  inline ::pb::Modification* mutable_static_mod(int index);
  inline ::pb::Modification* add_static_mod();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Modification >&
      static_mod() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Modification >*
      mutable_static_mod();

  // repeated double unique_deltas = 10;
  inline int unique_deltas_size() const;
  inline void clear_unique_deltas();
  static const int kUniqueDeltasFieldNumber = 10;
  inline double unique_deltas(int index) const;
  inline void set_unique_deltas(int index, double value);
  inline void add_unique_deltas(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      unique_deltas() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_unique_deltas();

  // @@protoc_insertion_point(class_scope:pb.ModTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::Modification > variable_mod_;
  ::google::protobuf::RepeatedPtrField< ::pb::Modification > static_mod_;
  ::google::protobuf::RepeatedField< double > unique_deltas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static ModTable* default_instance_;
};
// -------------------------------------------------------------------

class Header_Source : public ::google::protobuf::Message {
 public:
  Header_Source();
  virtual ~Header_Source();

  Header_Source(const Header_Source& from);

  inline Header_Source& operator=(const Header_Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_Source& default_instance();

  void Swap(Header_Source* other);

  // implements Message ----------------------------------------------

  Header_Source* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_Source& from);
  void MergeFrom(const Header_Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional .pb.Header header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::pb::Header& header() const;
  inline ::pb::Header* mutable_header();
  inline ::pb::Header* release_header();
  inline void set_allocated_header(::pb::Header* header);

  // optional string filetype = 3;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 3;
  inline const ::std::string& filetype() const;
  inline void set_filetype(const ::std::string& value);
  inline void set_filetype(const char* value);
  inline void set_filetype(const char* value, size_t size);
  inline ::std::string* mutable_filetype();
  inline ::std::string* release_filetype();
  inline void set_allocated_filetype(::std::string* filetype);

  // @@protoc_insertion_point(class_scope:pb.Header.Source)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_filetype();
  inline void clear_has_filetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::pb::Header* header_;
  ::std::string* filetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_Source* default_instance_;
};
// -------------------------------------------------------------------

class Header_RawProteinsHeader : public ::google::protobuf::Message {
 public:
  Header_RawProteinsHeader();
  virtual ~Header_RawProteinsHeader();

  Header_RawProteinsHeader(const Header_RawProteinsHeader& from);

  inline Header_RawProteinsHeader& operator=(const Header_RawProteinsHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_RawProteinsHeader& default_instance();

  void Swap(Header_RawProteinsHeader* other);

  // implements Message ----------------------------------------------

  Header_RawProteinsHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_RawProteinsHeader& from);
  void MergeFrom(const Header_RawProteinsHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.Header.RawProteinsHeader)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_RawProteinsHeader* default_instance_;
};
// -------------------------------------------------------------------

class Header_PeptidesHeader : public ::google::protobuf::Message {
 public:
  Header_PeptidesHeader();
  virtual ~Header_PeptidesHeader();

  Header_PeptidesHeader(const Header_PeptidesHeader& from);

  inline Header_PeptidesHeader& operator=(const Header_PeptidesHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_PeptidesHeader& default_instance();

  void Swap(Header_PeptidesHeader* other);

  // implements Message ----------------------------------------------

  Header_PeptidesHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_PeptidesHeader& from);
  void MergeFrom(const Header_PeptidesHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double min_mass = 3;
  inline bool has_min_mass() const;
  inline void clear_min_mass();
  static const int kMinMassFieldNumber = 3;
  inline double min_mass() const;
  inline void set_min_mass(double value);

  // optional double max_mass = 4;
  inline bool has_max_mass() const;
  inline void clear_max_mass();
  static const int kMaxMassFieldNumber = 4;
  inline double max_mass() const;
  inline void set_max_mass(double value);

  // optional int32 min_length = 5;
  inline bool has_min_length() const;
  inline void clear_min_length();
  static const int kMinLengthFieldNumber = 5;
  inline ::google::protobuf::int32 min_length() const;
  inline void set_min_length(::google::protobuf::int32 value);

  // optional int32 max_length = 6;
  inline bool has_max_length() const;
  inline void clear_max_length();
  static const int kMaxLengthFieldNumber = 6;
  inline ::google::protobuf::int32 max_length() const;
  inline void set_max_length(::google::protobuf::int32 value);

  // optional string enzyme = 7;
  inline bool has_enzyme() const;
  inline void clear_enzyme();
  static const int kEnzymeFieldNumber = 7;
  inline const ::std::string& enzyme() const;
  inline void set_enzyme(const ::std::string& value);
  inline void set_enzyme(const char* value);
  inline void set_enzyme(const char* value, size_t size);
  inline ::std::string* mutable_enzyme();
  inline ::std::string* release_enzyme();
  inline void set_allocated_enzyme(::std::string* enzyme);

  // optional bool full_digestion = 8;
  inline bool has_full_digestion() const;
  inline void clear_full_digestion();
  static const int kFullDigestionFieldNumber = 8;
  inline bool full_digestion() const;
  inline void set_full_digestion(bool value);

  // optional int32 max_missed_cleavages = 14;
  inline bool has_max_missed_cleavages() const;
  inline void clear_max_missed_cleavages();
  static const int kMaxMissedCleavagesFieldNumber = 14;
  inline ::google::protobuf::int32 max_missed_cleavages() const;
  inline void set_max_missed_cleavages(::google::protobuf::int32 value);

  // optional bool monoisotopic_precursor = 13;
  inline bool has_monoisotopic_precursor() const;
  inline void clear_monoisotopic_precursor();
  static const int kMonoisotopicPrecursorFieldNumber = 13;
  inline bool monoisotopic_precursor() const;
  inline void set_monoisotopic_precursor(bool value);

  // optional bool has_peaks = 10;
  inline bool has_has_peaks() const;
  inline void clear_has_peaks();
  static const int kHasPeaksFieldNumber = 10;
  inline bool has_peaks() const;
  inline void set_has_peaks(bool value);

  // optional double downselect_fraction = 11;
  inline bool has_downselect_fraction() const;
  inline void clear_downselect_fraction();
  static const int kDownselectFractionFieldNumber = 11;
  inline double downselect_fraction() const;
  inline void set_downselect_fraction(double value);

  // optional .pb.ModTable mods = 12;
  inline bool has_mods() const;
  inline void clear_mods();
  static const int kModsFieldNumber = 12;
  inline const ::pb::ModTable& mods() const;
  inline ::pb::ModTable* mutable_mods();
  inline ::pb::ModTable* release_mods();
  inline void set_allocated_mods(::pb::ModTable* mods);

  // optional .pb.ModTable nterm_mods = 15;
  inline bool has_nterm_mods() const;
  inline void clear_nterm_mods();
  static const int kNtermModsFieldNumber = 15;
  inline const ::pb::ModTable& nterm_mods() const;
  inline ::pb::ModTable* mutable_nterm_mods();
  inline ::pb::ModTable* release_nterm_mods();
  inline void set_allocated_nterm_mods(::pb::ModTable* nterm_mods);

  // optional .pb.ModTable cterm_mods = 16;
  inline bool has_cterm_mods() const;
  inline void clear_cterm_mods();
  static const int kCtermModsFieldNumber = 16;
  inline const ::pb::ModTable& cterm_mods() const;
  inline ::pb::ModTable* mutable_cterm_mods();
  inline ::pb::ModTable* release_cterm_mods();
  inline void set_allocated_cterm_mods(::pb::ModTable* cterm_mods);

  // optional int32 decoys = 9;
  inline bool has_decoys() const;
  inline void clear_decoys();
  static const int kDecoysFieldNumber = 9;
  inline ::google::protobuf::int32 decoys() const;
  inline void set_decoys(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Header.PeptidesHeader)
 private:
  inline void set_has_min_mass();
  inline void clear_has_min_mass();
  inline void set_has_max_mass();
  inline void clear_has_max_mass();
  inline void set_has_min_length();
  inline void clear_has_min_length();
  inline void set_has_max_length();
  inline void clear_has_max_length();
  inline void set_has_enzyme();
  inline void clear_has_enzyme();
  inline void set_has_full_digestion();
  inline void clear_has_full_digestion();
  inline void set_has_max_missed_cleavages();
  inline void clear_has_max_missed_cleavages();
  inline void set_has_monoisotopic_precursor();
  inline void clear_has_monoisotopic_precursor();
  inline void set_has_has_peaks();
  inline void clear_has_has_peaks();
  inline void set_has_downselect_fraction();
  inline void clear_has_downselect_fraction();
  inline void set_has_mods();
  inline void clear_has_mods();
  inline void set_has_nterm_mods();
  inline void clear_has_nterm_mods();
  inline void set_has_cterm_mods();
  inline void clear_has_cterm_mods();
  inline void set_has_decoys();
  inline void clear_has_decoys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double min_mass_;
  double max_mass_;
  ::google::protobuf::int32 min_length_;
  ::google::protobuf::int32 max_length_;
  ::std::string* enzyme_;
  ::google::protobuf::int32 max_missed_cleavages_;
  bool full_digestion_;
  bool monoisotopic_precursor_;
  bool has_peaks_;
  double downselect_fraction_;
  ::pb::ModTable* mods_;
  ::pb::ModTable* nterm_mods_;
  ::pb::ModTable* cterm_mods_;
  ::google::protobuf::int32 decoys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_PeptidesHeader* default_instance_;
};
// -------------------------------------------------------------------

class Header_SpectraHeader : public ::google::protobuf::Message {
 public:
  Header_SpectraHeader();
  virtual ~Header_SpectraHeader();

  Header_SpectraHeader(const Header_SpectraHeader& from);

  inline Header_SpectraHeader& operator=(const Header_SpectraHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_SpectraHeader& default_instance();

  void Swap(Header_SpectraHeader* other);

  // implements Message ----------------------------------------------

  Header_SpectraHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_SpectraHeader& from);
  void MergeFrom(const Header_SpectraHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool sorted = 2;
  inline bool has_sorted() const;
  inline void clear_sorted();
  static const int kSortedFieldNumber = 2;
  inline bool sorted() const;
  inline void set_sorted(bool value);

  // @@protoc_insertion_point(class_scope:pb.Header.SpectraHeader)
 private:
  inline void set_has_sorted();
  inline void clear_has_sorted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool sorted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_SpectraHeader* default_instance_;
};
// -------------------------------------------------------------------

class Header_ResultsHeader : public ::google::protobuf::Message {
 public:
  Header_ResultsHeader();
  virtual ~Header_ResultsHeader();

  Header_ResultsHeader(const Header_ResultsHeader& from);

  inline Header_ResultsHeader& operator=(const Header_ResultsHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_ResultsHeader& default_instance();

  void Swap(Header_ResultsHeader* other);

  // implements Message ----------------------------------------------

  Header_ResultsHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_ResultsHeader& from);
  void MergeFrom(const Header_ResultsHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double mass_window = 1;
  inline bool has_mass_window() const;
  inline void clear_mass_window();
  static const int kMassWindowFieldNumber = 1;
  inline double mass_window() const;
  inline void set_mass_window(double value);

  // optional int32 top_matches = 2;
  inline bool has_top_matches() const;
  inline void clear_top_matches();
  static const int kTopMatchesFieldNumber = 2;
  inline ::google::protobuf::int32 top_matches() const;
  inline void set_top_matches(::google::protobuf::int32 value);

  // optional .pb.Header.PeptidesHeader peptides_header = 3;
  inline bool has_peptides_header() const;
  inline void clear_peptides_header();
  static const int kPeptidesHeaderFieldNumber = 3;
  inline const ::pb::Header_PeptidesHeader& peptides_header() const;
  inline ::pb::Header_PeptidesHeader* mutable_peptides_header();
  inline ::pb::Header_PeptidesHeader* release_peptides_header();
  inline void set_allocated_peptides_header(::pb::Header_PeptidesHeader* peptides_header);

  // @@protoc_insertion_point(class_scope:pb.Header.ResultsHeader)
 private:
  inline void set_has_mass_window();
  inline void clear_has_mass_window();
  inline void set_has_top_matches();
  inline void clear_has_top_matches();
  inline void set_has_peptides_header();
  inline void clear_has_peptides_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double mass_window_;
  ::pb::Header_PeptidesHeader* peptides_header_;
  ::google::protobuf::int32 top_matches_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_ResultsHeader* default_instance_;
};
// -------------------------------------------------------------------

class Header_AuxLocationsHeader : public ::google::protobuf::Message {
 public:
  Header_AuxLocationsHeader();
  virtual ~Header_AuxLocationsHeader();

  Header_AuxLocationsHeader(const Header_AuxLocationsHeader& from);

  inline Header_AuxLocationsHeader& operator=(const Header_AuxLocationsHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header_AuxLocationsHeader& default_instance();

  void Swap(Header_AuxLocationsHeader* other);

  // implements Message ----------------------------------------------

  Header_AuxLocationsHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header_AuxLocationsHeader& from);
  void MergeFrom(const Header_AuxLocationsHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.Header.AuxLocationsHeader)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header_AuxLocationsHeader* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Header_Source Source;
  typedef Header_RawProteinsHeader RawProteinsHeader;
  typedef Header_PeptidesHeader PeptidesHeader;
  typedef Header_SpectraHeader SpectraHeader;
  typedef Header_ResultsHeader ResultsHeader;
  typedef Header_AuxLocationsHeader AuxLocationsHeader;

  typedef Header_FileType FileType;
  static const FileType RAW_PROTEINS = Header_FileType_RAW_PROTEINS;
  static const FileType PEPTIDES = Header_FileType_PEPTIDES;
  static const FileType SPECTRA = Header_FileType_SPECTRA;
  static const FileType PARAMS = Header_FileType_PARAMS;
  static const FileType MOD_TABLE = Header_FileType_MOD_TABLE;
  static const FileType RESULTS = Header_FileType_RESULTS;
  static const FileType AUX_LOCATIONS = Header_FileType_AUX_LOCATIONS;
  static inline bool FileType_IsValid(int value) {
    return Header_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    Header_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    Header_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    Header_FileType_FileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FileType_descriptor() {
    return Header_FileType_descriptor();
  }
  static inline const ::std::string& FileType_Name(FileType value) {
    return Header_FileType_Name(value);
  }
  static inline bool FileType_Parse(const ::std::string& name,
      FileType* value) {
    return Header_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .pb.Header.Source source = 1;
  inline int source_size() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::pb::Header_Source& source(int index) const;
  inline ::pb::Header_Source* mutable_source(int index);
  inline ::pb::Header_Source* add_source();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Header_Source >&
      source() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Header_Source >*
      mutable_source();

  // required .pb.Header.FileType file_type = 2;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 2;
  inline ::pb::Header_FileType file_type() const;
  inline void set_file_type(::pb::Header_FileType value);

  // optional .pb.Header.RawProteinsHeader raw_proteins_header = 3;
  inline bool has_raw_proteins_header() const;
  inline void clear_raw_proteins_header();
  static const int kRawProteinsHeaderFieldNumber = 3;
  inline const ::pb::Header_RawProteinsHeader& raw_proteins_header() const;
  inline ::pb::Header_RawProteinsHeader* mutable_raw_proteins_header();
  inline ::pb::Header_RawProteinsHeader* release_raw_proteins_header();
  inline void set_allocated_raw_proteins_header(::pb::Header_RawProteinsHeader* raw_proteins_header);

  // optional .pb.Header.PeptidesHeader peptides_header = 4;
  inline bool has_peptides_header() const;
  inline void clear_peptides_header();
  static const int kPeptidesHeaderFieldNumber = 4;
  inline const ::pb::Header_PeptidesHeader& peptides_header() const;
  inline ::pb::Header_PeptidesHeader* mutable_peptides_header();
  inline ::pb::Header_PeptidesHeader* release_peptides_header();
  inline void set_allocated_peptides_header(::pb::Header_PeptidesHeader* peptides_header);

  // optional .pb.Header.SpectraHeader spectra_header = 5;
  inline bool has_spectra_header() const;
  inline void clear_spectra_header();
  static const int kSpectraHeaderFieldNumber = 5;
  inline const ::pb::Header_SpectraHeader& spectra_header() const;
  inline ::pb::Header_SpectraHeader* mutable_spectra_header();
  inline ::pb::Header_SpectraHeader* release_spectra_header();
  inline void set_allocated_spectra_header(::pb::Header_SpectraHeader* spectra_header);

  // optional .pb.Header.ResultsHeader results_header = 6;
  inline bool has_results_header() const;
  inline void clear_results_header();
  static const int kResultsHeaderFieldNumber = 6;
  inline const ::pb::Header_ResultsHeader& results_header() const;
  inline ::pb::Header_ResultsHeader* mutable_results_header();
  inline ::pb::Header_ResultsHeader* release_results_header();
  inline void set_allocated_results_header(::pb::Header_ResultsHeader* results_header);

  // optional .pb.Header.AuxLocationsHeader aux_locs_header = 7;
  inline bool has_aux_locs_header() const;
  inline void clear_aux_locs_header();
  static const int kAuxLocsHeaderFieldNumber = 7;
  inline const ::pb::Header_AuxLocationsHeader& aux_locs_header() const;
  inline ::pb::Header_AuxLocationsHeader* mutable_aux_locs_header();
  inline ::pb::Header_AuxLocationsHeader* release_aux_locs_header();
  inline void set_allocated_aux_locs_header(::pb::Header_AuxLocationsHeader* aux_locs_header);

  // optional string command_line = 8;
  inline bool has_command_line() const;
  inline void clear_command_line();
  static const int kCommandLineFieldNumber = 8;
  inline const ::std::string& command_line() const;
  inline void set_command_line(const ::std::string& value);
  inline void set_command_line(const char* value);
  inline void set_command_line(const char* value, size_t size);
  inline ::std::string* mutable_command_line();
  inline ::std::string* release_command_line();
  inline void set_allocated_command_line(::std::string* command_line);

  // @@protoc_insertion_point(class_scope:pb.Header)
 private:
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_raw_proteins_header();
  inline void clear_has_raw_proteins_header();
  inline void set_has_peptides_header();
  inline void clear_has_peptides_header();
  inline void set_has_spectra_header();
  inline void clear_has_spectra_header();
  inline void set_has_results_header();
  inline void clear_has_results_header();
  inline void set_has_aux_locs_header();
  inline void clear_has_aux_locs_header();
  inline void set_has_command_line();
  inline void clear_has_command_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::Header_Source > source_;
  ::pb::Header_RawProteinsHeader* raw_proteins_header_;
  ::pb::Header_PeptidesHeader* peptides_header_;
  ::pb::Header_SpectraHeader* spectra_header_;
  ::pb::Header_ResultsHeader* results_header_;
  ::pb::Header_AuxLocationsHeader* aux_locs_header_;
  ::std::string* command_line_;
  int file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_header_2eproto();
  friend void protobuf_AssignDesc_header_2eproto();
  friend void protobuf_ShutdownFile_header_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// ===================================================================


// ===================================================================

// Modification

// optional string amino_acids = 1;
inline bool Modification::has_amino_acids() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Modification::set_has_amino_acids() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Modification::clear_has_amino_acids() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Modification::clear_amino_acids() {
  if (amino_acids_ != &::google::protobuf::internal::kEmptyString) {
    amino_acids_->clear();
  }
  clear_has_amino_acids();
}
inline const ::std::string& Modification::amino_acids() const {
  return *amino_acids_;
}
inline void Modification::set_amino_acids(const ::std::string& value) {
  set_has_amino_acids();
  if (amino_acids_ == &::google::protobuf::internal::kEmptyString) {
    amino_acids_ = new ::std::string;
  }
  amino_acids_->assign(value);
}
inline void Modification::set_amino_acids(const char* value) {
  set_has_amino_acids();
  if (amino_acids_ == &::google::protobuf::internal::kEmptyString) {
    amino_acids_ = new ::std::string;
  }
  amino_acids_->assign(value);
}
inline void Modification::set_amino_acids(const char* value, size_t size) {
  set_has_amino_acids();
  if (amino_acids_ == &::google::protobuf::internal::kEmptyString) {
    amino_acids_ = new ::std::string;
  }
  amino_acids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Modification::mutable_amino_acids() {
  set_has_amino_acids();
  if (amino_acids_ == &::google::protobuf::internal::kEmptyString) {
    amino_acids_ = new ::std::string;
  }
  return amino_acids_;
}
inline ::std::string* Modification::release_amino_acids() {
  clear_has_amino_acids();
  if (amino_acids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amino_acids_;
    amino_acids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Modification::set_allocated_amino_acids(::std::string* amino_acids) {
  if (amino_acids_ != &::google::protobuf::internal::kEmptyString) {
    delete amino_acids_;
  }
  if (amino_acids) {
    set_has_amino_acids();
    amino_acids_ = amino_acids;
  } else {
    clear_has_amino_acids();
    amino_acids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double delta = 2;
inline bool Modification::has_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Modification::set_has_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Modification::clear_has_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Modification::clear_delta() {
  delta_ = 0;
  clear_has_delta();
}
inline double Modification::delta() const {
  return delta_;
}
inline void Modification::set_delta(double value) {
  set_has_delta();
  delta_ = value;
}

// optional int32 max_count = 3;
inline bool Modification::has_max_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Modification::set_has_max_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Modification::clear_has_max_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Modification::clear_max_count() {
  max_count_ = 0;
  clear_has_max_count();
}
inline ::google::protobuf::int32 Modification::max_count() const {
  return max_count_;
}
inline void Modification::set_max_count(::google::protobuf::int32 value) {
  set_has_max_count();
  max_count_ = value;
}

// -------------------------------------------------------------------

// ModTable

// repeated .pb.Modification variable_mod = 1;
inline int ModTable::variable_mod_size() const {
  return variable_mod_.size();
}
inline void ModTable::clear_variable_mod() {
  variable_mod_.Clear();
}
inline const ::pb::Modification& ModTable::variable_mod(int index) const {
  return variable_mod_.Get(index);
}
inline ::pb::Modification* ModTable::mutable_variable_mod(int index) {
  return variable_mod_.Mutable(index);
}
inline ::pb::Modification* ModTable::add_variable_mod() {
  return variable_mod_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Modification >&
ModTable::variable_mod() const {
  return variable_mod_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Modification >*
ModTable::mutable_variable_mod() {
  return &variable_mod_;
}

// repeated .pb.Modification static_mod = 2;
inline int ModTable::static_mod_size() const {
  return static_mod_.size();
}
inline void ModTable::clear_static_mod() {
  static_mod_.Clear();
}
inline const ::pb::Modification& ModTable::static_mod(int index) const {
  return static_mod_.Get(index);
}
inline ::pb::Modification* ModTable::mutable_static_mod(int index) {
  return static_mod_.Mutable(index);
}
inline ::pb::Modification* ModTable::add_static_mod() {
  return static_mod_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Modification >&
ModTable::static_mod() const {
  return static_mod_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Modification >*
ModTable::mutable_static_mod() {
  return &static_mod_;
}

// repeated double unique_deltas = 10;
inline int ModTable::unique_deltas_size() const {
  return unique_deltas_.size();
}
inline void ModTable::clear_unique_deltas() {
  unique_deltas_.Clear();
}
inline double ModTable::unique_deltas(int index) const {
  return unique_deltas_.Get(index);
}
inline void ModTable::set_unique_deltas(int index, double value) {
  unique_deltas_.Set(index, value);
}
inline void ModTable::add_unique_deltas(double value) {
  unique_deltas_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ModTable::unique_deltas() const {
  return unique_deltas_;
}
inline ::google::protobuf::RepeatedField< double >*
ModTable::mutable_unique_deltas() {
  return &unique_deltas_;
}

// -------------------------------------------------------------------

// Header_Source

// optional string filename = 1;
inline bool Header_Source::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_Source::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_Source::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_Source::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Header_Source::filename() const {
  return *filename_;
}
inline void Header_Source::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Header_Source::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Header_Source::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header_Source::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Header_Source::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header_Source::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.Header header = 2;
inline bool Header_Source::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_Source::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_Source::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_Source::clear_header() {
  if (header_ != NULL) header_->::pb::Header::Clear();
  clear_has_header();
}
inline const ::pb::Header& Header_Source::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::pb::Header* Header_Source::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::pb::Header;
  return header_;
}
inline ::pb::Header* Header_Source::release_header() {
  clear_has_header();
  ::pb::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Header_Source::set_allocated_header(::pb::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional string filetype = 3;
inline bool Header_Source::has_filetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header_Source::set_has_filetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header_Source::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header_Source::clear_filetype() {
  if (filetype_ != &::google::protobuf::internal::kEmptyString) {
    filetype_->clear();
  }
  clear_has_filetype();
}
inline const ::std::string& Header_Source::filetype() const {
  return *filetype_;
}
inline void Header_Source::set_filetype(const ::std::string& value) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::kEmptyString) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(value);
}
inline void Header_Source::set_filetype(const char* value) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::kEmptyString) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(value);
}
inline void Header_Source::set_filetype(const char* value, size_t size) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::kEmptyString) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header_Source::mutable_filetype() {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::kEmptyString) {
    filetype_ = new ::std::string;
  }
  return filetype_;
}
inline ::std::string* Header_Source::release_filetype() {
  clear_has_filetype();
  if (filetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filetype_;
    filetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header_Source::set_allocated_filetype(::std::string* filetype) {
  if (filetype_ != &::google::protobuf::internal::kEmptyString) {
    delete filetype_;
  }
  if (filetype) {
    set_has_filetype();
    filetype_ = filetype;
  } else {
    clear_has_filetype();
    filetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Header_RawProteinsHeader

// -------------------------------------------------------------------

// Header_PeptidesHeader

// optional double min_mass = 3;
inline bool Header_PeptidesHeader::has_min_mass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_PeptidesHeader::set_has_min_mass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_PeptidesHeader::clear_has_min_mass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_PeptidesHeader::clear_min_mass() {
  min_mass_ = 0;
  clear_has_min_mass();
}
inline double Header_PeptidesHeader::min_mass() const {
  return min_mass_;
}
inline void Header_PeptidesHeader::set_min_mass(double value) {
  set_has_min_mass();
  min_mass_ = value;
}

// optional double max_mass = 4;
inline bool Header_PeptidesHeader::has_max_mass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_PeptidesHeader::set_has_max_mass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_PeptidesHeader::clear_has_max_mass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_PeptidesHeader::clear_max_mass() {
  max_mass_ = 0;
  clear_has_max_mass();
}
inline double Header_PeptidesHeader::max_mass() const {
  return max_mass_;
}
inline void Header_PeptidesHeader::set_max_mass(double value) {
  set_has_max_mass();
  max_mass_ = value;
}

// optional int32 min_length = 5;
inline bool Header_PeptidesHeader::has_min_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header_PeptidesHeader::set_has_min_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header_PeptidesHeader::clear_has_min_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header_PeptidesHeader::clear_min_length() {
  min_length_ = 0;
  clear_has_min_length();
}
inline ::google::protobuf::int32 Header_PeptidesHeader::min_length() const {
  return min_length_;
}
inline void Header_PeptidesHeader::set_min_length(::google::protobuf::int32 value) {
  set_has_min_length();
  min_length_ = value;
}

// optional int32 max_length = 6;
inline bool Header_PeptidesHeader::has_max_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header_PeptidesHeader::set_has_max_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header_PeptidesHeader::clear_has_max_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header_PeptidesHeader::clear_max_length() {
  max_length_ = 0;
  clear_has_max_length();
}
inline ::google::protobuf::int32 Header_PeptidesHeader::max_length() const {
  return max_length_;
}
inline void Header_PeptidesHeader::set_max_length(::google::protobuf::int32 value) {
  set_has_max_length();
  max_length_ = value;
}

// optional string enzyme = 7;
inline bool Header_PeptidesHeader::has_enzyme() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header_PeptidesHeader::set_has_enzyme() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header_PeptidesHeader::clear_has_enzyme() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header_PeptidesHeader::clear_enzyme() {
  if (enzyme_ != &::google::protobuf::internal::kEmptyString) {
    enzyme_->clear();
  }
  clear_has_enzyme();
}
inline const ::std::string& Header_PeptidesHeader::enzyme() const {
  return *enzyme_;
}
inline void Header_PeptidesHeader::set_enzyme(const ::std::string& value) {
  set_has_enzyme();
  if (enzyme_ == &::google::protobuf::internal::kEmptyString) {
    enzyme_ = new ::std::string;
  }
  enzyme_->assign(value);
}
inline void Header_PeptidesHeader::set_enzyme(const char* value) {
  set_has_enzyme();
  if (enzyme_ == &::google::protobuf::internal::kEmptyString) {
    enzyme_ = new ::std::string;
  }
  enzyme_->assign(value);
}
inline void Header_PeptidesHeader::set_enzyme(const char* value, size_t size) {
  set_has_enzyme();
  if (enzyme_ == &::google::protobuf::internal::kEmptyString) {
    enzyme_ = new ::std::string;
  }
  enzyme_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header_PeptidesHeader::mutable_enzyme() {
  set_has_enzyme();
  if (enzyme_ == &::google::protobuf::internal::kEmptyString) {
    enzyme_ = new ::std::string;
  }
  return enzyme_;
}
inline ::std::string* Header_PeptidesHeader::release_enzyme() {
  clear_has_enzyme();
  if (enzyme_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enzyme_;
    enzyme_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header_PeptidesHeader::set_allocated_enzyme(::std::string* enzyme) {
  if (enzyme_ != &::google::protobuf::internal::kEmptyString) {
    delete enzyme_;
  }
  if (enzyme) {
    set_has_enzyme();
    enzyme_ = enzyme;
  } else {
    clear_has_enzyme();
    enzyme_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool full_digestion = 8;
inline bool Header_PeptidesHeader::has_full_digestion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header_PeptidesHeader::set_has_full_digestion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header_PeptidesHeader::clear_has_full_digestion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header_PeptidesHeader::clear_full_digestion() {
  full_digestion_ = false;
  clear_has_full_digestion();
}
inline bool Header_PeptidesHeader::full_digestion() const {
  return full_digestion_;
}
inline void Header_PeptidesHeader::set_full_digestion(bool value) {
  set_has_full_digestion();
  full_digestion_ = value;
}

// optional int32 max_missed_cleavages = 14;
inline bool Header_PeptidesHeader::has_max_missed_cleavages() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header_PeptidesHeader::set_has_max_missed_cleavages() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header_PeptidesHeader::clear_has_max_missed_cleavages() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header_PeptidesHeader::clear_max_missed_cleavages() {
  max_missed_cleavages_ = 0;
  clear_has_max_missed_cleavages();
}
inline ::google::protobuf::int32 Header_PeptidesHeader::max_missed_cleavages() const {
  return max_missed_cleavages_;
}
inline void Header_PeptidesHeader::set_max_missed_cleavages(::google::protobuf::int32 value) {
  set_has_max_missed_cleavages();
  max_missed_cleavages_ = value;
}

// optional bool monoisotopic_precursor = 13;
inline bool Header_PeptidesHeader::has_monoisotopic_precursor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header_PeptidesHeader::set_has_monoisotopic_precursor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header_PeptidesHeader::clear_has_monoisotopic_precursor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header_PeptidesHeader::clear_monoisotopic_precursor() {
  monoisotopic_precursor_ = false;
  clear_has_monoisotopic_precursor();
}
inline bool Header_PeptidesHeader::monoisotopic_precursor() const {
  return monoisotopic_precursor_;
}
inline void Header_PeptidesHeader::set_monoisotopic_precursor(bool value) {
  set_has_monoisotopic_precursor();
  monoisotopic_precursor_ = value;
}

// optional bool has_peaks = 10;
inline bool Header_PeptidesHeader::has_has_peaks() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header_PeptidesHeader::set_has_has_peaks() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header_PeptidesHeader::clear_has_has_peaks() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header_PeptidesHeader::clear_has_peaks() {
  has_peaks_ = false;
  clear_has_has_peaks();
}
inline bool Header_PeptidesHeader::has_peaks() const {
  return has_peaks_;
}
inline void Header_PeptidesHeader::set_has_peaks(bool value) {
  set_has_has_peaks();
  has_peaks_ = value;
}

// optional double downselect_fraction = 11;
inline bool Header_PeptidesHeader::has_downselect_fraction() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header_PeptidesHeader::set_has_downselect_fraction() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header_PeptidesHeader::clear_has_downselect_fraction() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header_PeptidesHeader::clear_downselect_fraction() {
  downselect_fraction_ = 0;
  clear_has_downselect_fraction();
}
inline double Header_PeptidesHeader::downselect_fraction() const {
  return downselect_fraction_;
}
inline void Header_PeptidesHeader::set_downselect_fraction(double value) {
  set_has_downselect_fraction();
  downselect_fraction_ = value;
}

// optional .pb.ModTable mods = 12;
inline bool Header_PeptidesHeader::has_mods() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Header_PeptidesHeader::set_has_mods() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Header_PeptidesHeader::clear_has_mods() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Header_PeptidesHeader::clear_mods() {
  if (mods_ != NULL) mods_->::pb::ModTable::Clear();
  clear_has_mods();
}
inline const ::pb::ModTable& Header_PeptidesHeader::mods() const {
  return mods_ != NULL ? *mods_ : *default_instance_->mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::mutable_mods() {
  set_has_mods();
  if (mods_ == NULL) mods_ = new ::pb::ModTable;
  return mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::release_mods() {
  clear_has_mods();
  ::pb::ModTable* temp = mods_;
  mods_ = NULL;
  return temp;
}
inline void Header_PeptidesHeader::set_allocated_mods(::pb::ModTable* mods) {
  delete mods_;
  mods_ = mods;
  if (mods) {
    set_has_mods();
  } else {
    clear_has_mods();
  }
}

// optional .pb.ModTable nterm_mods = 15;
inline bool Header_PeptidesHeader::has_nterm_mods() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Header_PeptidesHeader::set_has_nterm_mods() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Header_PeptidesHeader::clear_has_nterm_mods() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Header_PeptidesHeader::clear_nterm_mods() {
  if (nterm_mods_ != NULL) nterm_mods_->::pb::ModTable::Clear();
  clear_has_nterm_mods();
}
inline const ::pb::ModTable& Header_PeptidesHeader::nterm_mods() const {
  return nterm_mods_ != NULL ? *nterm_mods_ : *default_instance_->nterm_mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::mutable_nterm_mods() {
  set_has_nterm_mods();
  if (nterm_mods_ == NULL) nterm_mods_ = new ::pb::ModTable;
  return nterm_mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::release_nterm_mods() {
  clear_has_nterm_mods();
  ::pb::ModTable* temp = nterm_mods_;
  nterm_mods_ = NULL;
  return temp;
}
inline void Header_PeptidesHeader::set_allocated_nterm_mods(::pb::ModTable* nterm_mods) {
  delete nterm_mods_;
  nterm_mods_ = nterm_mods;
  if (nterm_mods) {
    set_has_nterm_mods();
  } else {
    clear_has_nterm_mods();
  }
}

// optional .pb.ModTable cterm_mods = 16;
inline bool Header_PeptidesHeader::has_cterm_mods() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Header_PeptidesHeader::set_has_cterm_mods() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Header_PeptidesHeader::clear_has_cterm_mods() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Header_PeptidesHeader::clear_cterm_mods() {
  if (cterm_mods_ != NULL) cterm_mods_->::pb::ModTable::Clear();
  clear_has_cterm_mods();
}
inline const ::pb::ModTable& Header_PeptidesHeader::cterm_mods() const {
  return cterm_mods_ != NULL ? *cterm_mods_ : *default_instance_->cterm_mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::mutable_cterm_mods() {
  set_has_cterm_mods();
  if (cterm_mods_ == NULL) cterm_mods_ = new ::pb::ModTable;
  return cterm_mods_;
}
inline ::pb::ModTable* Header_PeptidesHeader::release_cterm_mods() {
  clear_has_cterm_mods();
  ::pb::ModTable* temp = cterm_mods_;
  cterm_mods_ = NULL;
  return temp;
}
inline void Header_PeptidesHeader::set_allocated_cterm_mods(::pb::ModTable* cterm_mods) {
  delete cterm_mods_;
  cterm_mods_ = cterm_mods;
  if (cterm_mods) {
    set_has_cterm_mods();
  } else {
    clear_has_cterm_mods();
  }
}

// optional int32 decoys = 9;
inline bool Header_PeptidesHeader::has_decoys() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Header_PeptidesHeader::set_has_decoys() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Header_PeptidesHeader::clear_has_decoys() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Header_PeptidesHeader::clear_decoys() {
  decoys_ = 0;
  clear_has_decoys();
}
inline ::google::protobuf::int32 Header_PeptidesHeader::decoys() const {
  return decoys_;
}
inline void Header_PeptidesHeader::set_decoys(::google::protobuf::int32 value) {
  set_has_decoys();
  decoys_ = value;
}

// -------------------------------------------------------------------

// Header_SpectraHeader

// optional bool sorted = 2;
inline bool Header_SpectraHeader::has_sorted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_SpectraHeader::set_has_sorted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_SpectraHeader::clear_has_sorted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_SpectraHeader::clear_sorted() {
  sorted_ = false;
  clear_has_sorted();
}
inline bool Header_SpectraHeader::sorted() const {
  return sorted_;
}
inline void Header_SpectraHeader::set_sorted(bool value) {
  set_has_sorted();
  sorted_ = value;
}

// -------------------------------------------------------------------

// Header_ResultsHeader

// optional double mass_window = 1;
inline bool Header_ResultsHeader::has_mass_window() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header_ResultsHeader::set_has_mass_window() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header_ResultsHeader::clear_has_mass_window() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header_ResultsHeader::clear_mass_window() {
  mass_window_ = 0;
  clear_has_mass_window();
}
inline double Header_ResultsHeader::mass_window() const {
  return mass_window_;
}
inline void Header_ResultsHeader::set_mass_window(double value) {
  set_has_mass_window();
  mass_window_ = value;
}

// optional int32 top_matches = 2;
inline bool Header_ResultsHeader::has_top_matches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header_ResultsHeader::set_has_top_matches() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header_ResultsHeader::clear_has_top_matches() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header_ResultsHeader::clear_top_matches() {
  top_matches_ = 0;
  clear_has_top_matches();
}
inline ::google::protobuf::int32 Header_ResultsHeader::top_matches() const {
  return top_matches_;
}
inline void Header_ResultsHeader::set_top_matches(::google::protobuf::int32 value) {
  set_has_top_matches();
  top_matches_ = value;
}

// optional .pb.Header.PeptidesHeader peptides_header = 3;
inline bool Header_ResultsHeader::has_peptides_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header_ResultsHeader::set_has_peptides_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header_ResultsHeader::clear_has_peptides_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header_ResultsHeader::clear_peptides_header() {
  if (peptides_header_ != NULL) peptides_header_->::pb::Header_PeptidesHeader::Clear();
  clear_has_peptides_header();
}
inline const ::pb::Header_PeptidesHeader& Header_ResultsHeader::peptides_header() const {
  return peptides_header_ != NULL ? *peptides_header_ : *default_instance_->peptides_header_;
}
inline ::pb::Header_PeptidesHeader* Header_ResultsHeader::mutable_peptides_header() {
  set_has_peptides_header();
  if (peptides_header_ == NULL) peptides_header_ = new ::pb::Header_PeptidesHeader;
  return peptides_header_;
}
inline ::pb::Header_PeptidesHeader* Header_ResultsHeader::release_peptides_header() {
  clear_has_peptides_header();
  ::pb::Header_PeptidesHeader* temp = peptides_header_;
  peptides_header_ = NULL;
  return temp;
}
inline void Header_ResultsHeader::set_allocated_peptides_header(::pb::Header_PeptidesHeader* peptides_header) {
  delete peptides_header_;
  peptides_header_ = peptides_header;
  if (peptides_header) {
    set_has_peptides_header();
  } else {
    clear_has_peptides_header();
  }
}

// -------------------------------------------------------------------

// Header_AuxLocationsHeader

// -------------------------------------------------------------------

// Header

// repeated .pb.Header.Source source = 1;
inline int Header::source_size() const {
  return source_.size();
}
inline void Header::clear_source() {
  source_.Clear();
}
inline const ::pb::Header_Source& Header::source(int index) const {
  return source_.Get(index);
}
inline ::pb::Header_Source* Header::mutable_source(int index) {
  return source_.Mutable(index);
}
inline ::pb::Header_Source* Header::add_source() {
  return source_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Header_Source >&
Header::source() const {
  return source_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Header_Source >*
Header::mutable_source() {
  return &source_;
}

// required .pb.Header.FileType file_type = 2;
inline bool Header::has_file_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_file_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_file_type() {
  file_type_ = 0;
  clear_has_file_type();
}
inline ::pb::Header_FileType Header::file_type() const {
  return static_cast< ::pb::Header_FileType >(file_type_);
}
inline void Header::set_file_type(::pb::Header_FileType value) {
  assert(::pb::Header_FileType_IsValid(value));
  set_has_file_type();
  file_type_ = value;
}

// optional .pb.Header.RawProteinsHeader raw_proteins_header = 3;
inline bool Header::has_raw_proteins_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_raw_proteins_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_raw_proteins_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_raw_proteins_header() {
  if (raw_proteins_header_ != NULL) raw_proteins_header_->::pb::Header_RawProteinsHeader::Clear();
  clear_has_raw_proteins_header();
}
inline const ::pb::Header_RawProteinsHeader& Header::raw_proteins_header() const {
  return raw_proteins_header_ != NULL ? *raw_proteins_header_ : *default_instance_->raw_proteins_header_;
}
inline ::pb::Header_RawProteinsHeader* Header::mutable_raw_proteins_header() {
  set_has_raw_proteins_header();
  if (raw_proteins_header_ == NULL) raw_proteins_header_ = new ::pb::Header_RawProteinsHeader;
  return raw_proteins_header_;
}
inline ::pb::Header_RawProteinsHeader* Header::release_raw_proteins_header() {
  clear_has_raw_proteins_header();
  ::pb::Header_RawProteinsHeader* temp = raw_proteins_header_;
  raw_proteins_header_ = NULL;
  return temp;
}
inline void Header::set_allocated_raw_proteins_header(::pb::Header_RawProteinsHeader* raw_proteins_header) {
  delete raw_proteins_header_;
  raw_proteins_header_ = raw_proteins_header;
  if (raw_proteins_header) {
    set_has_raw_proteins_header();
  } else {
    clear_has_raw_proteins_header();
  }
}

// optional .pb.Header.PeptidesHeader peptides_header = 4;
inline bool Header::has_peptides_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_peptides_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_peptides_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_peptides_header() {
  if (peptides_header_ != NULL) peptides_header_->::pb::Header_PeptidesHeader::Clear();
  clear_has_peptides_header();
}
inline const ::pb::Header_PeptidesHeader& Header::peptides_header() const {
  return peptides_header_ != NULL ? *peptides_header_ : *default_instance_->peptides_header_;
}
inline ::pb::Header_PeptidesHeader* Header::mutable_peptides_header() {
  set_has_peptides_header();
  if (peptides_header_ == NULL) peptides_header_ = new ::pb::Header_PeptidesHeader;
  return peptides_header_;
}
inline ::pb::Header_PeptidesHeader* Header::release_peptides_header() {
  clear_has_peptides_header();
  ::pb::Header_PeptidesHeader* temp = peptides_header_;
  peptides_header_ = NULL;
  return temp;
}
inline void Header::set_allocated_peptides_header(::pb::Header_PeptidesHeader* peptides_header) {
  delete peptides_header_;
  peptides_header_ = peptides_header;
  if (peptides_header) {
    set_has_peptides_header();
  } else {
    clear_has_peptides_header();
  }
}

// optional .pb.Header.SpectraHeader spectra_header = 5;
inline bool Header::has_spectra_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_spectra_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_spectra_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_spectra_header() {
  if (spectra_header_ != NULL) spectra_header_->::pb::Header_SpectraHeader::Clear();
  clear_has_spectra_header();
}
inline const ::pb::Header_SpectraHeader& Header::spectra_header() const {
  return spectra_header_ != NULL ? *spectra_header_ : *default_instance_->spectra_header_;
}
inline ::pb::Header_SpectraHeader* Header::mutable_spectra_header() {
  set_has_spectra_header();
  if (spectra_header_ == NULL) spectra_header_ = new ::pb::Header_SpectraHeader;
  return spectra_header_;
}
inline ::pb::Header_SpectraHeader* Header::release_spectra_header() {
  clear_has_spectra_header();
  ::pb::Header_SpectraHeader* temp = spectra_header_;
  spectra_header_ = NULL;
  return temp;
}
inline void Header::set_allocated_spectra_header(::pb::Header_SpectraHeader* spectra_header) {
  delete spectra_header_;
  spectra_header_ = spectra_header;
  if (spectra_header) {
    set_has_spectra_header();
  } else {
    clear_has_spectra_header();
  }
}

// optional .pb.Header.ResultsHeader results_header = 6;
inline bool Header::has_results_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_results_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_results_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_results_header() {
  if (results_header_ != NULL) results_header_->::pb::Header_ResultsHeader::Clear();
  clear_has_results_header();
}
inline const ::pb::Header_ResultsHeader& Header::results_header() const {
  return results_header_ != NULL ? *results_header_ : *default_instance_->results_header_;
}
inline ::pb::Header_ResultsHeader* Header::mutable_results_header() {
  set_has_results_header();
  if (results_header_ == NULL) results_header_ = new ::pb::Header_ResultsHeader;
  return results_header_;
}
inline ::pb::Header_ResultsHeader* Header::release_results_header() {
  clear_has_results_header();
  ::pb::Header_ResultsHeader* temp = results_header_;
  results_header_ = NULL;
  return temp;
}
inline void Header::set_allocated_results_header(::pb::Header_ResultsHeader* results_header) {
  delete results_header_;
  results_header_ = results_header;
  if (results_header) {
    set_has_results_header();
  } else {
    clear_has_results_header();
  }
}

// optional .pb.Header.AuxLocationsHeader aux_locs_header = 7;
inline bool Header::has_aux_locs_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_aux_locs_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_aux_locs_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_aux_locs_header() {
  if (aux_locs_header_ != NULL) aux_locs_header_->::pb::Header_AuxLocationsHeader::Clear();
  clear_has_aux_locs_header();
}
inline const ::pb::Header_AuxLocationsHeader& Header::aux_locs_header() const {
  return aux_locs_header_ != NULL ? *aux_locs_header_ : *default_instance_->aux_locs_header_;
}
inline ::pb::Header_AuxLocationsHeader* Header::mutable_aux_locs_header() {
  set_has_aux_locs_header();
  if (aux_locs_header_ == NULL) aux_locs_header_ = new ::pb::Header_AuxLocationsHeader;
  return aux_locs_header_;
}
inline ::pb::Header_AuxLocationsHeader* Header::release_aux_locs_header() {
  clear_has_aux_locs_header();
  ::pb::Header_AuxLocationsHeader* temp = aux_locs_header_;
  aux_locs_header_ = NULL;
  return temp;
}
inline void Header::set_allocated_aux_locs_header(::pb::Header_AuxLocationsHeader* aux_locs_header) {
  delete aux_locs_header_;
  aux_locs_header_ = aux_locs_header;
  if (aux_locs_header) {
    set_has_aux_locs_header();
  } else {
    clear_has_aux_locs_header();
  }
}

// optional string command_line = 8;
inline bool Header::has_command_line() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_command_line() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_command_line() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_command_line() {
  if (command_line_ != &::google::protobuf::internal::kEmptyString) {
    command_line_->clear();
  }
  clear_has_command_line();
}
inline const ::std::string& Header::command_line() const {
  return *command_line_;
}
inline void Header::set_command_line(const ::std::string& value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void Header::set_command_line(const char* value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void Header::set_command_line(const char* value, size_t size) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_command_line() {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  return command_line_;
}
inline ::std::string* Header::release_command_line() {
  clear_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_line_;
    command_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_command_line(::std::string* command_line) {
  if (command_line_ != &::google::protobuf::internal::kEmptyString) {
    delete command_line_;
  }
  if (command_line) {
    set_has_command_line();
    command_line_ = command_line;
  } else {
    clear_has_command_line();
    command_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Header_FileType>() {
  return ::pb::Header_FileType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_header_2eproto__INCLUDED
